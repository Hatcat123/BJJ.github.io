---
title: 封装一个有用的仿站工具
tags:
  - python
  - 开发
categories:
  - python
copyright: true
permalink: 封装一个有用的仿站工具
top: 0
password: woaini2.
abstract: 输入密码继续阅读.
message: 欢迎来到我的博客，输入密码继续阅读.
date: 2019-07-15 12:45:16
---

使用wget仿站，效率原来这么高！
人生苦短我用python

<!--more-->

下载全站的内容，思路用requests模拟爬虫，简易的画出了架构图，这里存在着几个问题。



```

wget 是一个从网络上自动下载文件的自由工具。它支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。

所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。

wget可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时候，wget 遵循Robot Exclusion标准(/robots.txt). wget可以在下载的同时，将链接转换成指向本地文件，以方便离线浏览。

wget 非常稳定,它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务 器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。

wget的常见用法：

wget不但功能强大，而且使用起来比较简单，
基本的语法是：wget [参数列表] “URL” 用””引起来可以避免因URL中有特殊字符造成的下载出错。
下面就结合具体的例子来说明一下wget的用法。

1、下载整个http或者ftp站点。

wget http://place.your.url/here

这个命令可以将http://place.your.url/here 首页下载下来。使用-x会强制建立服务器上一模一样的目录，如果使用-nd参数，那么服务器上下载的所有内容都会加到本地当前目录。

wget -r http://place.your.url/here

这个命令会按照递归的方法，下载服务器上所有的目录和文件，实质就是下载整个网站。这个命令一定要小心使用，因为在下载的时候，被下载网站指向的所有地址 同样会被下载，因此，如果这个网站引用了其他网站，那么被引用的网站也会被下载下来！基于这个原因，这个参数不常用。可以用-l number参数来指定下载的层次。例如只下载两层，那么使用-l 2。

要是您想制作镜像站点，那么可以使用－m参数，例如：
wget -m http://place.your.url/here
这时wget会自动判断合适的参数来制作镜像站点。此时，wget会登录到服务器上，读入robots.txt并按robots.txt的规定来执行。

2、断点续传。

当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。wget的断点续传是自动的，只需要使用-c参数，例如：
wget -c http://the.url.of/incomplete/file

使用断点续传要求服务器支持断点续传。-t参数表示重试次数，例如需要重试100次，那么就写-t 100，如果设成-t 0，那么表示无穷次重试，直到连接成功。-T参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时。

3、批量下载。

如果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件download.txt，然后用命令：wget -i download.txt
这样就会把download.txt里面列出的每个URL都下载下来。（如果列的是文件就下载文件，如果列的是网站，那么下载首页）

4、选择性的下载。

可以指定让wget只下载一类文件，或者不下载什么文件。例如：
wget -m –reject=gif http://target.web.site/subdirectory
表示下载http://target.web.site/subdirectory，但是忽略gif文件。–accept=LIST 可以接受的文件类型，–reject=LIST拒绝接受的文件类型。

5、密码和认证。

wget只能处理利用用户名/密码方式限制访问的网站，可以利用两个参数：
–http-user=USER设置HTTP用户
–http-passwd=PASS设置HTTP密码
对于需要证书做认证的网站，就只能利用其他下载工具了，例如curl。

6、利用代理服务器进行下载。

如果用户的网络需要经过代理服务器，那么可以让wget通过代理服务器进行文件的下载。此时需要在当前用户的目录下创建一个.wgetrc文件。文件中可以设置代理服务器：
http-proxy = 111.111.111.111:8080
ftp-proxy = 111.111.111.111:8080
分别表示http的代理服务器和ftp的代理服务器。如果代理服务器需要密码则使用：
–proxy-user=USER设置代理用户
–proxy-passwd=PASS设置代理密码
这两个参数。
使用参数–proxy=on/off 使用或者关闭代理。
wget还有很多有用的功能，需要用户去挖掘。

wget的使用格式

Usage: wget [OPTION]… [URL]…

* 用wget做站点镜像:
wget -r -p -np -k http://dsec.pku.edu.cn/~usr_name/
# 或者wget -m http://dsec.pku.edu.cn/~usr_name/

* 在不稳定的网络上下载一个部分下载的文件，以及在空闲时段下载
wget -t 0 -w 31 -c http://dsec.pku.edu.cn/BBC.avi -o down.log &
# 或者从filelist读入要下载的文件列表
wget -t 0 -w 31 -c -B ftp://dsec.pku.edu.cn/linuxsoft -i filelist.txt -o down.log &
上面的代码还可以用来在网络比较空闲的时段进行下载。我的用法是:在mozilla中将不方便当时下载的URL链接拷贝到内存中然后粘贴到文件 filelist.txt中，在晚上要出去系统前执行上面代码的第二条。

* 使用代理下载
wget -Y on -p -k https://sourceforge.net/projects/wvware/
代理可以在环境变量或wgetrc文件中设定
# 在环境变量中设定代理
export PROXY=http://211.90.168.94:8080/
# 在~/.wgetrc中设定代理
http_proxy = http://proxy.yoyodyne.com:18023/
ftp_proxy = http://proxy.yoyodyne.com:18023/

wget各种选项分类列表

* 启动
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc
* 记录和输入文件
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名
* 下载
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率
* 目录
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录
* HTTP 选项
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS.
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许).
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION.
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接).
–cookies=off 不使用 cookies.
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中
* FTP 选项
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)
* 递归下载
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷).
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr.
-p, –page-requisites 下载显示HTML文件的所有图片
* 递归下载中的包含和不包含(accept/reject)
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程

```



## 如何封装到天衣无缝？

不能有一丝痕迹暴露出使用了`wget.exe`，选择打印输出为简单模式。将`wget.exe`封装到新的exe包中。在封装之后，调用的运行路径，其实是exe内部的路径。

一个访问生成资源内部文件目录的方法
```
# 生成资源文件目录访问路径
def resource_path(self, relative_path):
    if getattr(sys, 'frozen', False):  # 是否Bundle Resource
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

```

** 封装命令 **

将某个目录下的文件都放到exe中的对应目录

```
pyinstaller -F \copy_web\web_copy_v1.2.py -c -i D:\copy_web\1.ico --add-data \copy_web\test;test
```

>延伸 当以后想要在内部使用一个sqlite数据库的时候，就可以吧数据库封装到exe中，然后本地文件的读取与存储也能正常的运行

## 部分源码
```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
__author__ = 'AJay'
__mtime__ = '2019/7/4 0004'

"""
import sys
import os


class Copy_Web(object):
    def __init__(self):
        self._init_config()
        self.base_path = os.path.dirname(os.path.abspath(__file__))
        self.exe_path = self.resource_path(os.path.join("test", "wget.exe"))
        self.read_config()

    # 生成资源文件目录访问路径
    def resource_path(self, relative_path):
        if getattr(sys, 'frozen', False):  # 是否Bundle Resource
            base_path = sys._MEIPASS
        else:
            base_path = os.path.abspath(".")
        return os.path.join(base_path, relative_path)

    def _init_config(self):
        print('万能仿站助手v1.2')
        print('说明：\n 快速仿站,本软件只用于学习使用，禁止用数据钓鱼，从事一切违法犯罪行为与软件无关，后果自负。')
        print('版本v1.1：增加适应非html结尾文件的仿站')
        print('版本v1.2：更改适应html的选项配置文件')
        print(
            '注意事项：\n  1、不能修改config.ini的格式，配置信息只能在“====”中修改。\n  2、仿站的速度根据自身的带宽、目标网站的响应速度、网站的内容数量以及线程决定。\n  3、频繁访问可能被waf识别为恶意访问，导致存在被封ip的可能。\n  4、不支持js动态加载页面的爬取。\n')
        print('开始加载配置文件')

    def input(self):
        self.domain = input('请输入需要仿站的域名：\n')
        if self.domain=='':
            return

    def read_config(self):
        with open(os.path.join(self.base_path, 'config.ini'), 'r', encoding='utf-8')as f:
            config_contents = f.readlines()
            for per_config in config_contents:
                per_config_list = per_config.split('==')
                print(per_config)
                if 'continue' in per_config_list[0]:
                    self.continu = per_config_list[1]
                    continue
                elif 'deepth' in per_config_list[0]:
                    self.deepth = per_config_list[1]
                    continue
                elif 'thread' in per_config_list[0]:
                    self.thread = per_config_list[1]
                    continue
                elif 'robots' in per_config_list[0]:
                    self.robots = per_config_list[1]
                    continue
                elif 'timeout' in per_config_list[0]:
                    self.timeout = per_config_list[1]
                    continue
                elif 'retry' in per_config_list[0]:
                    self.retry = per_config_list[1]
                    continue
                elif 'save_file' in per_config_list[0]:
                    self.save_file = per_config_list[1]
                    continue
                elif 'all_html' in per_config_list[0]:
                    self.all_html = per_config_list[1]
                    continue

    # 配置文件中的命令
    def _continu(self):
        # 设置断网重连，当断网后，再次运行程序会在原文件基础继续下载， 1 代表开启 0代表关闭。默认开启1\n'
        if self.continu == '1':
            return ' -c '
        else:
            return ''

    def _deepth(self):
        # 设置爬虫深度
        return '-l {} '.format(int(self.deepth))

    def _robots(self):
        # //设置遵循robots协议
        if self.robots == '0':
            return '-e robots=off '
        else:
            return ''

    def _timeout(self):
        # 设置超时时间，
        return '-T {} '.format(int(self.timeout))

    def _thread(self):
        # //设置线程
        return ''

    def _retry(self):
        # 设置重连次数
        return '-t {} '.format(int(self.retry))

    def _save_file(self):  # TODO：设置保存路径
        # 设置保存路径
        # if os.path.exists(self.save_file):
            return '-P {} '.format((self.save_file))
        # else:
        #     return ''

    def _html_extension(self):
        # 将所有的文档以html进行拓展
        if self.all_html == '1':
            return '-E '
        else:
            return ''

    # 内置默认命令
    def _mirror(self):
        # mirror             -N -r -l inf --no-remove-listing 的缩写形式。
        return '-m '

    def _default_header(self):
        # 标识为 AGENT 而不是 Wget/VERSION。
        return '--user-agent="Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36" '

    def _https(self):
        # https时不要验证服务器的证书。
        return '--no-check-certificate '

    def _loca_link(self):
        # 让下载得到的 HTML 或 CSS 中的链接指向本地文件
        return '-k '

    def _down_all(self):
        # 下载所有用于显示 HTML 页面的图片之类的元素。
        return '-p '

    def _referer(self):
        # 在 HTTP 请求头包含‘Referer: URL’
        return '--referer={}'.format(self.domain)

    def _no_verbose(self):
        # 关闭冗长模式
        return  ' -nv '

    def _run_wget(self):
        '''
        命令选择 wget的命令选择
        # 内置命令
        _mirror: clone镜像
        _default_header： 标识为 AGENT 而不是 Wget/VERSION。
        _https：https时不要验证服务器的证书。
        _loca_link：让下载得到的 HTML 或 CSS 中的链接指向本地文件。
        _down_all：下载全部的内容html，图片，css，js
        _referer： 在 HTTP 请求头包含‘Referer: URL’。
        _no_verbose：关闭冗长模式
       # 外置命令
        _continu：设置断网重连
        _deepth：最大递归深度( inf 或 0 代表无限制，即全部下载)。
        _thread：设置线程
        _robots：爬取不遵守robots协议
        _timeout： 将所有超时设为 SECONDS 秒。
        _retry： 设置重试次数为 NUMBER (0 代表无限制)。
        _save_file： 以 PREFIX/... 保存文件
        _html_extension：将所有的文档以html进行拓展

        '''
        all = ["_mirror", "_default_header", "_https", "_loca_link", "_down_all", "_referer","_no_verbose",
               "_continu", "_deepth", "_thread", "_robots", "_timeout", "_retry", "_save_file","_html_extension",
               ]
        command = ' '
        command += self._mirror()
        command += self._default_header()
        command += self._https()
        command += self._loca_link()
        command += self._down_all()
        command += self._referer()
        command += self._continu()
        command += self._deepth()
        command += self._thread()
        command += self._robots()
        command += self._timeout()
        command += self._retry()
        command += self._html_extension()
        command += self._save_file()
        command += self._no_verbose()
        command += self.domain

        # print(self.exe_path +command)
        print('开始爬取')
        os.system(self.exe_path + command)

    def run(self):
        self.input()
        self._run_wget()
        print('爬取结束')
        print('打开目录{}提取文件'.format(self.save_file))
        input()

if __name__ == '__main__':
    cw = Copy_Web()
    cw.run()

```